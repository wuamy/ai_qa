# db.py
# --- 1. Import necessary libraries from SQLAlchemy and Python's standard library ---
from sqlalchemy import create_engine, Column, Integer, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

# --- 2. Database Model Definition ---

# `declarative_base()` returns a new base class from which all mapped classes should inherit.
# This serves as the foundation for our database tables.
Base = declarative_base()

class PromptRun(Base):
    """
    This is the SQLAlchemy ORM (Object-Relational Mapping) model for our database table.
    Each instance of this class will correspond to a row in the 'prompt_runs' table.
    """
    # Define the name of the database table
    __tablename__ = 'prompt_runs'
    
    # Define the columns for the table. Each Column is an attribute of the class.
    # `id`: An integer column that serves as the primary key. SQLAlchemy auto-increments this.
    id = Column(Integer, primary_key=True)
    
    # `timestamp`: A DateTime column that defaults to the current UTC time when a new record is created.
    # This helps in tracking when each prompt was run.
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    # `input_prompt`: A Text column to store the user's input request. `nullable=False` means it cannot be empty.
    input_prompt = Column(Text, nullable=False)
    
    # `output_json`: A Text column to store the JSON output generated by the LLM.
    output_json = Column(Text, nullable=False)

# --- 3. Database Connection and Session Management ---

# Create a database engine. The `create_engine()` function connects to the database.
# We are using SQLite and storing the database in a file named 'qa_agent.db'.
engine = create_engine('sqlite:///qa_agent.db')

# Create the database table(s) defined by our models. If the table already exists, this does nothing.
Base.metadata.create_all(engine)

# `sessionmaker` is a factory for creating `Session` objects. The Session is the
# primary interface for talking to the database.
# `autocommit=False`: Transactions are managed manually.
# `autoflush=False`: Objects are not flushed to the database until `commit()` is called.
# `bind=engine`: Binds this session to our database engine.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# --- 4. Database Operations Functions ---

def save_prompt_run(input_prompt: str, output_json: str):
    """
    Saves a new prompt run record to the database.

    Args:
        input_prompt (str): The user's input string.
        output_json (str): The JSON output string generated by the LLM.
    """
    # Create a new database session
    db = SessionLocal()
    try:
        # Create a new instance of our model
        db_run = PromptRun(
            input_prompt=input_prompt,
            output_json=output_json
        )
        # Add the new object to the session
        db.add(db_run)
        # Commit the transaction to save the data to the database
        db.commit()
    finally:
        # Close the session to release the connection. This is crucial for resource management.
        db.close()

def get_all_runs():
    """
    Retrieves all prompt run records from the database, ordered by timestamp.

    Returns:
        List[PromptRun]: A list of all PromptRun objects.
    """
    db = SessionLocal()
    try:
        # Query the database for all records in the PromptRun table.
        # `order_by(PromptRun.timestamp.desc())` sorts the results from newest to oldest.
        return db.query(PromptRun).order_by(PromptRun.timestamp.desc()).all()
    finally:
        # Ensure the session is closed even if an error occurs.
        db.close()
        
def delete_prompt_runs(ids: list):
    """
    Deletes a list of records from the database by their IDs.

    Args:
        ids (list): A list of integer IDs of the records to be deleted.
    """
    # Do nothing if the list of IDs is empty to avoid unnecessary database operations.
    if not ids:
        return
    
    db = SessionLocal()
    try:
        # Build a delete query.
        # `.filter(PromptRun.id.in_(ids))` selects all records where the ID is in the provided list.
        # `.delete()` executes the deletion.
        # `synchronize_session=False` is used for bulk deletion, making it more efficient
        # as it doesn't need to load objects into the session first.
        db.query(PromptRun).filter(PromptRun.id.in_(ids)).delete(synchronize_session=False)
        # Commit the transaction to apply the deletion to the database.
        db.commit()
    finally:
        db.close()